"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  Filter: () => Filter
});
module.exports = __toCommonJS(src_exports);

// src/lang.ts
var words = [
  "ahole",
  "anus",
  "ash0le",
  "ash0les",
  "asholes",
  "ass",
  "Ass Monkey",
  "Assface",
  "assh0le",
  "assh0lez",
  "asshole",
  "assholes",
  "assholz",
  "asswipe",
  "azzhole",
  "bassterds",
  "bastard",
  "bastards",
  "bastardz",
  "basterds",
  "basterdz",
  "Biatch",
  "bitch",
  "bitches",
  "Blow Job",
  "boffing",
  "butthole",
  "buttwipe",
  "c0ck",
  "c0cks",
  "c0k",
  "Carpet Muncher",
  "cawk",
  "cawks",
  "Clit",
  "cnts",
  "cntz",
  "cock",
  "cockhead",
  "cock-head",
  "cocks",
  "CockSucker",
  "cock-sucker",
  "crap",
  "cum",
  "cunt",
  "cunts",
  "cuntz",
  "dick",
  "dild0",
  "dild0s",
  "dildo",
  "dildos",
  "dilld0",
  "dilld0s",
  "dominatricks",
  "dominatrics",
  "dominatrix",
  "dyke",
  "enema",
  "f u c k",
  "f u c k e r",
  "fag",
  "fag1t",
  "faget",
  "fagg1t",
  "faggit",
  "faggot",
  "fagg0t",
  "fagit",
  "fags",
  "fagz",
  "faig",
  "faigs",
  "fart",
  "flipping the bird",
  "fuck",
  "fucker",
  "fuckin",
  "fucking",
  "fucks",
  "Fudge Packer",
  "fuk",
  "Fukah",
  "Fuken",
  "fuker",
  "Fukin",
  "Fukk",
  "Fukkah",
  "Fukken",
  "Fukker",
  "Fukkin",
  "g00k",
  "God-damned",
  "h00r",
  "h0ar",
  "h0re",
  "hells",
  "hoar",
  "hoor",
  "hoore",
  "jackoff",
  "jap",
  "japs",
  "jerk-off",
  "jisim",
  "jiss",
  "jizm",
  "jizz",
  "knob",
  "knobs",
  "knobz",
  "kunt",
  "kunts",
  "kuntz",
  "Lezzian",
  "Lipshits",
  "Lipshitz",
  "masochist",
  "masokist",
  "massterbait",
  "masstrbait",
  "masstrbate",
  "masterbaiter",
  "masterbate",
  "masterbates",
  "Motha Fucker",
  "Motha Fuker",
  "Motha Fukkah",
  "Motha Fukker",
  "Mother Fucker",
  "Mother Fukah",
  "Mother Fuker",
  "Mother Fukkah",
  "Mother Fukker",
  "mother-fucker",
  "Mutha Fucker",
  "Mutha Fukah",
  "Mutha Fuker",
  "Mutha Fukkah",
  "Mutha Fukker",
  "n1gr",
  "nastt",
  "nigger;",
  "nigur;",
  "niiger;",
  "niigr;",
  "orafis",
  "orgasim;",
  "orgasm",
  "orgasum",
  "oriface",
  "orifice",
  "orifiss",
  "packi",
  "packie",
  "packy",
  "paki",
  "pakie",
  "paky",
  "pecker",
  "peeenus",
  "peeenusss",
  "peenus",
  "peinus",
  "pen1s",
  "penas",
  "penis",
  "penis-breath",
  "penus",
  "penuus",
  "Phuc",
  "Phuck",
  "Phuk",
  "Phuker",
  "Phukker",
  "polac",
  "polack",
  "polak",
  "Poonani",
  "pr1c",
  "pr1ck",
  "pr1k",
  "pusse",
  "pussee",
  "pussy",
  "puuke",
  "puuker",
  "qweir",
  "recktum",
  "rectum",
  "retard",
  "sadist",
  "scank",
  "schlong",
  "screwing",
  "semen",
  "sex",
  "sexy",
  "Sh!t",
  "sh1t",
  "sh1ter",
  "sh1ts",
  "sh1tter",
  "sh1tz",
  "shit",
  "shits",
  "shitter",
  "Shitty",
  "Shity",
  "shitz",
  "Shyt",
  "Shyte",
  "Shytty",
  "Shyty",
  "skanck",
  "skank",
  "skankee",
  "skankey",
  "skanks",
  "Skanky",
  "slag",
  "slut",
  "sluts",
  "Slutty",
  "slutz",
  "son-of-a-bitch",
  "tit",
  "turd",
  "va1jina",
  "vag1na",
  "vagiina",
  "vagina",
  "vaj1na",
  "vajina",
  "vullva",
  "vulva",
  "w0p",
  "wh00r",
  "wh0re",
  "whore",
  "xrated",
  "xxx",
  "b!+ch",
  "blowjob",
  "clit",
  "arschloch",
  "b!tch",
  "b17ch",
  "b1tch",
  "bi+ch",
  "boiolas",
  "buceta",
  "chink",
  "cipa",
  "clits",
  "dirsa",
  "ejakulate",
  "fatass",
  "fcuk",
  "fux0r",
  "hoer",
  "hore",
  "jism",
  "kawk",
  "l3itch",
  "l3i+ch",
  "masturbate",
  "masterbat*",
  "masterbat3",
  "motherfucker",
  "s.o.b.",
  "mofo",
  "nazi",
  "nigga",
  "nigger",
  "nutsack",
  "phuck",
  "pimpis",
  "scrotum",
  "sh!t",
  "shemale",
  "shi+",
  "sh!+",
  "smut",
  "teets",
  "tits",
  "boobs",
  "b00bs",
  "teez",
  "testical",
  "testicle",
  "titt",
  "w00se",
  "wank",
  "whoar",
  "*damn",
  "*dyke",
  "*fuck*",
  "*shit*",
  "@$$",
  "amcik",
  "andskota",
  "arse*",
  "assrammer",
  "ayir",
  "bi7ch",
  "bitch*",
  "bollock*",
  "breasts",
  "butt-pirate",
  "cabron",
  "cazzo",
  "chraa",
  "chuj",
  "Cock*",
  "cunt*",
  "d4mn",
  "daygo",
  "dego",
  "dick*",
  "dike*",
  "dupa",
  "dziwka",
  "ejackulate",
  "Ekrem*",
  "Ekto",
  "enculer",
  "faen",
  "fag*",
  "fanculo",
  "fanny",
  "feces",
  "feg",
  "Felcher",
  "ficken",
  "fitt*",
  "Flikker",
  "foreskin",
  "Fotze",
  "Fu(*",
  "fuk*",
  "futkretzn",
  "gook",
  "guiena",
  "h0r",
  "h4x0r",
  "hell",
  "helvete",
  "hoer*",
  "honkey",
  "Huevon",
  "hui",
  "injun",
  "kanker*",
  "kike",
  "klootzak",
  "kraut",
  "knulle",
  "kuk",
  "kuksuger",
  "Kurac",
  "kurwa",
  "kusi*",
  "kyrpa*",
  "lesbo",
  "mamhoon",
  "masturbat*",
  "merd*",
  "mibun",
  "monkleigh",
  "mouliewop",
  "muie",
  "mulkku",
  "muschi",
  "nazis",
  "nepesaurio",
  "nigger*",
  "orospu",
  "paska*",
  "perse",
  "picka",
  "pierdol*",
  "pillu*",
  "pimmel",
  "piss*",
  "pizda",
  "poontsee",
  "poop",
  "porn",
  "p0rn",
  "pr0n",
  "preteen",
  "pula",
  "pule",
  "puta",
  "puto",
  "qahbeh",
  "queef*",
  "rautenberg",
  "schaffer",
  "scheiss*",
  "schlampe",
  "schmuck",
  "screw",
  "sh!t*",
  "sharmuta",
  "sharmute",
  "shipal",
  "shiz",
  "skribz",
  "skurwysyn",
  "sphencter",
  "spic",
  "spierdalaj",
  "splooge",
  "suka",
  "b00b*",
  "testicle*",
  "titt*",
  "twat",
  "vittu",
  "wank*",
  "wetback*",
  "wichser",
  "wop*",
  "yed",
  "zabourah",
  "4r5e",
  "5h1t",
  "5hit",
  "a55",
  "anal",
  "ar5e",
  "arrse",
  "arse",
  "ass-fucker",
  "asses",
  "assfucker",
  "assfukka",
  "asswhole",
  "a_s_s",
  "ballbag",
  "balls",
  "ballsack",
  "beastial",
  "beastiality",
  "bellend",
  "bestial",
  "bestiality",
  "biatch",
  "bitcher",
  "bitchers",
  "bitchin",
  "bitching",
  "bloody",
  "blow job",
  "blowjobs",
  "bollock",
  "bollok",
  "boner",
  "boob",
  "booobs",
  "boooobs",
  "booooobs",
  "booooooobs",
  "bugger",
  "bum",
  "bunny fucker",
  "butt",
  "buttmuch",
  "buttplug",
  "c0cksucker",
  "carpet muncher",
  "cl1t",
  "clitoris",
  "cnut",
  "cockface",
  "cockmunch",
  "cockmuncher",
  "cocksuck",
  "cocksucked",
  "cocksucker",
  "cocksucking",
  "cocksucks",
  "cocksuka",
  "cocksukka",
  "cok",
  "cokmuncher",
  "coksucka",
  "coon",
  "cox",
  "cummer",
  "cumming",
  "cums",
  "cumshot",
  "cunilingus",
  "cunillingus",
  "cunnilingus",
  "cuntlick",
  "cuntlicker",
  "cuntlicking",
  "cyalis",
  "cyberfuc",
  "cyberfuck",
  "cyberfucked",
  "cyberfucker",
  "cyberfuckers",
  "cyberfucking",
  "d1ck",
  "damn",
  "dickhead",
  "dink",
  "dinks",
  "dlck",
  "dog-fucker",
  "doggin",
  "dogging",
  "donkeyribber",
  "doosh",
  "duche",
  "ejaculate",
  "ejaculated",
  "ejaculates",
  "ejaculating",
  "ejaculatings",
  "ejaculation",
  "f4nny",
  "fagging",
  "faggitt",
  "faggs",
  "fagot",
  "fagots",
  "fannyflaps",
  "fannyfucker",
  "fanyy",
  "fcuker",
  "fcuking",
  "feck",
  "fecker",
  "felching",
  "fellate",
  "fellatio",
  "fingerfuck",
  "fingerfucked",
  "fingerfucker",
  "fingerfuckers",
  "fingerfucking",
  "fingerfucks",
  "fistfuck",
  "fistfucked",
  "fistfucker",
  "fistfuckers",
  "fistfucking",
  "fistfuckings",
  "fistfucks",
  "flange",
  "fook",
  "fooker",
  "fucka",
  "fucked",
  "fuckers",
  "fuckhead",
  "fuckheads",
  "fuckings",
  "fuckingshitmotherfucker",
  "fuckme",
  "fuckwhit",
  "fuckwit",
  "fudge packer",
  "fudgepacker",
  "fukker",
  "fukkin",
  "fuks",
  "fukwhit",
  "fukwit",
  "fux",
  "f_u_c_k",
  "gangbang",
  "gangbanged",
  "gangbangs",
  "gaylord",
  "gaysex",
  "goatse",
  "God",
  "god-dam",
  "god-damned",
  "goddamn",
  "goddamned",
  "hardcoresex",
  "heshe",
  "hoare",
  "homo",
  "horniest",
  "horny",
  "hotsex",
  "jack-off",
  "jiz",
  "knobead",
  "knobed",
  "knobend",
  "knobhead",
  "knobjocky",
  "knobjokey",
  "kock",
  "kondum",
  "kondums",
  "kum",
  "kummer",
  "kumming",
  "kums",
  "kunilingus",
  "labia",
  "lust",
  "lusting",
  "m0f0",
  "m0fo",
  "m45terbate",
  "ma5terb8",
  "ma5terbate",
  "master-bate",
  "masterb8",
  "masterbation",
  "masterbations",
  "mo-fo",
  "mof0",
  "mothafuck",
  "mothafucka",
  "mothafuckas",
  "mothafuckaz",
  "mothafucked",
  "mothafucker",
  "mothafuckers",
  "mothafuckin",
  "mothafucking",
  "mothafuckings",
  "mothafucks",
  "mother fucker",
  "motherfuck",
  "motherfucked",
  "motherfuckers",
  "motherfuckin",
  "motherfucking",
  "motherfuckings",
  "motherfuckka",
  "motherfucks",
  "muff",
  "mutha",
  "muthafecker",
  "muthafuckker",
  "muther",
  "mutherfucker",
  "n1gga",
  "n1gger",
  "nigg3r",
  "nigg4h",
  "niggah",
  "niggas",
  "niggaz",
  "niggers",
  "nob",
  "nob jokey",
  "nobhead",
  "nobjocky",
  "nobjokey",
  "numbnuts",
  "orgasim",
  "orgasims",
  "orgasms",
  "pawn",
  "penisfucker",
  "phonesex",
  "phuk",
  "phuked",
  "phuking",
  "phukked",
  "phukking",
  "phuks",
  "phuq",
  "pigfucker",
  "piss",
  "pissed",
  "pisser",
  "pissers",
  "pisses",
  "pissflaps",
  "pissin",
  "pissing",
  "pissoff",
  "porno",
  "pornography",
  "pornos",
  "prick",
  "pricks",
  "pron",
  "pube",
  "pussi",
  "pussies",
  "pussys",
  "rimjaw",
  "rimming",
  "s hit",
  "scroat",
  "scrote",
  "shag",
  "shagger",
  "shaggin",
  "shagging",
  "shitdick",
  "shite",
  "shited",
  "shitey",
  "shitfuck",
  "shitfull",
  "shithead",
  "shiting",
  "shitings",
  "shitted",
  "shitters",
  "shitting",
  "shittings",
  "shitty",
  "smegma",
  "snatch",
  "spac",
  "spunk",
  "s_h_i_t",
  "t1tt1e5",
  "t1tties",
  "titfuck",
  "tittie5",
  "tittiefucker",
  "titties",
  "tittyfuck",
  "tittywank",
  "titwank",
  "tosser",
  "tw4t",
  "twathead",
  "twatty",
  "twunt",
  "twunter",
  "v14gra",
  "v1gra",
  "viagra",
  "wang",
  "wanker",
  "wanky",
  "willies",
  "willy"
];

// src/filter.ts
var Filter = class {
  /**
   * Filter constructor. To use AI functions must set in .env or pass as param: OPEN_MODERATOR_API_KEY
   * @constructor
   * @param {object} options - Filter instance options
   * @param {boolean} options.emptyList - Instantiate filter with no blacklist
   * @param {array} options.list - Instantiate filter with a custom list
   * @param {string} options.placeHolder - Character used to replace profane words.
   * @param {string} options.regex - Regular expression used to sanitize words before comparing them to the blacklist.
   * @param {string} options.replaceRegex - Regular expression used to replace profane words with placeHolder.
   * @param {string} options.splitRegex - Regular expression used to split a string into words.
   * @param {string} options.contentCheckerAPIKey - API key for OpenModerator API
   */
  constructor(options = {}) {
    this.list = options.emptyList ? [] : [...words, ...options.list || []];
    this.exclude = options.exclude || [];
    this.splitRegex = options.splitRegex || /\b/;
    this.placeHolder = options.placeHolder || "*";
    this.regex = options.regex || /[^a-zA-Z0-9|$|@]|\^/g;
    this.replaceRegex = options.replaceRegex || /\w/g;
    this.openModeratorAPIKey = process.env.OPEN_MODERATOR_API_KEY || options.openModeratorAPIKey;
  }
  /**
   * Determine if a string contains profane language.
   * @param {string} string - String to evaluate for profanity.
   */
  isProfane(string) {
    return this.list.some((word) => {
      const cleanWord = word.replace(/(\W)/g, "\\$1");
      const wordExp = new RegExp(`\\b${cleanWord}(?:${cleanWord})*\\b`, "gi");
      return !this.exclude.includes(word.toLowerCase()) && wordExp.test(string);
    });
  }
  /**
   * Replace a word with placeHolder characters;
   * @param {string} string - String to replace.
   */
  replaceWord(string) {
    return string.replace(this.regex, "").replace(this.replaceRegex, this.placeHolder);
  }
  /**
   * Evaluate a string for profanity and return an edited version.
   * @param {string} string - Sentence to filter.
   */
  clean(string) {
    var _a;
    if (string === "")
      return "";
    const words2 = string.split(this.splitRegex);
    const delimiter = ((_a = this.splitRegex.exec(string)) == null ? void 0 : _a[0]) || "";
    return words2.map((word) => {
      return this.isProfane(word) ? this.replaceWord(word) : word;
    }).join(delimiter);
  }
  /**
   * Add word(s) to blacklist filter / remove words from whitelist filter
   * @param {...string} words - Word(s) to add to the blacklist
   */
  addWords(...words2) {
    this.list.push(...words2);
    words2.map((word) => word.toLowerCase()).forEach((word) => {
      if (this.exclude.includes(word)) {
        this.exclude.splice(this.exclude.indexOf(word), 1);
      }
    });
  }
  /**
   * Add words to whitelist filter
   * @param {...string} words - Word(s) to add to the whitelist.
   */
  removeWords(...words2) {
    this.exclude.push(...words2.map((word) => word.toLowerCase()));
  }
  /**
   * AI-enabled way to determine if a string contains profane language. Ensure that you've set an API key for OpenModerator
   * @param {string} str - String to evaluate for profanity.
   * @param {ProfanityCheckConfig} config - Configuration object containing checkManualProfanityList and provider.
   * In config: provider can be "openai" (OpenAI's Moderation API) or "google-perspective-api" (Google's Perspective API) or "google-natural-language-api" (Google's Natural Language API)
   * In config: checkManualProfanityList is a boolean to determine if the manual profanity list in lang.ts should be checked first.
   * @returns {Promise<{ profane: boolean; type: string[] }>} - Object containing profane flag and types of detected content ("PROFANITY")
   */
  isProfaneAI(_0) {
    return __async(this, arguments, function* (str, config = {
      checkManualProfanityList: false,
      provider: "google-perspective-api"
    }) {
      if (!this.openModeratorAPIKey) {
        console.warn(
          "No API key found. AI functions will not work. Set in .env or pass as param: OPEN_MODERATOR_API_KEY"
        );
        throw new Error("OpenModerator API key is not set.");
      }
      const data = {
        prompt: str,
        config
      };
      const contentCheckerAPIUrl = "https://www.openmoderator.com/api/moderate/text";
      try {
        const response = yield fetch(contentCheckerAPIUrl, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            "x-api-key": this.openModeratorAPIKey || ""
          },
          body: JSON.stringify(data)
        });
        return yield response.json();
      } catch (error) {
        console.error("Error calling OpenModerator API", error);
        throw error;
      }
    });
  }
  /**
   * AI-enabled way to determine if an image contains NSFW content.
   * Ensure that you've set an API key for OpenModerator.
   * @param {Blob} image - Image file (jpg, png) to evaluate for NSFW content.
   * @returns {Promise<{ nsfw: boolean; types: string[] }>} - Object containing NSFW flag and types of detected content ("Hentai" or "Porn")
   */
  isImageNSFW(image) {
    return __async(this, null, function* () {
      if (!this.openModeratorAPIKey) {
        console.warn(
          "No API key found. AI functions will not work. Set in .env or pass as param: OPEN_MODERATOR_API_KEY"
        );
        throw new Error("OpenModerator API key is not set.");
      }
      const formData = new FormData();
      formData.append("file", image);
      const contentCheckerAPIUrl = "https://www.openmoderator.com/api/moderate/image";
      try {
        const response = yield fetch(contentCheckerAPIUrl, {
          method: "POST",
          headers: {
            "x-api-key": (this == null ? void 0 : this.openModeratorAPIKey) || ""
          },
          body: formData
        });
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        return yield response.json();
      } catch (error) {
        console.error("Error calling OpenModerator API", error);
        throw error;
      }
    });
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  Filter
});
//# sourceMappingURL=index.cjs.map